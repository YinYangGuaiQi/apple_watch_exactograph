<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Reversed Outer Ring Clock</title>
  <style>
    @font-face {
      font-family: 'PingFangMedium';
      src: url('PingFangMedium.ttf') format('truetype');
      font-weight: normal;
      font-style: normal;
    }

    html,body{
      height:100%;margin:0;
      background:#000;
      overflow:hidden;
    }

    canvas{
      position:absolute;
      top:0;
      left:0;
      background:transparent;
    }
  </style>
</head>
<body>
<canvas id="c"></canvas>
<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  let params;

  // ---------- 初始化尺寸 ----------
  function resize() {
    canvas.width = innerWidth;
    canvas.height = innerHeight;
    const base = Math.min(innerWidth, innerHeight);

    params = {
      center: { x: innerWidth / 2, y: innerHeight / 2 },

      rHour: base * 0.2,
      rHourCircle: base * 0.2,

      rMin: base * 2,
      rSec: base * 3,

      lMin: base * 0.3,
      lSec: base * 0.42,

      fixedMin: base * 2 - base * 0.3,
      fixedSec: base * 3 - base * 0.42,

      tickLength: {
        major: base * 0.057,
        medium: base * 0.038,
        minor: base * 0.024
      },

      fontOuter: `${base * 0.038}px 'PingFangMedium'`,
      fontHour: `${base * 0.067}px 'PingFangMedium'`,
      numOuterOffset: -base * 0.076,
      numHourOffset: -base * 0.095,

      color: {
        hour: "#f0f0f0",
        min: "#ffeadd",
        sec: "#f0f0f0"
      }
    };
  }
  resize();
  addEventListener('resize', resize);

  // ---------- 颜色变暗 ----------
  function darken(hex, factor) {
    hex = hex.replace(/^#/, "");
    if (hex.length === 3) hex = hex.split("").map(x => x + x).join("");

    const r = Math.floor(parseInt(hex.substr(0,2),16) * (1-factor));
    const g = Math.floor(parseInt(hex.substr(2,2),16) * (1-factor));
    const b = Math.floor(parseInt(hex.substr(4,2),16) * (1-factor));

    return `#${r.toString(16).padStart(2,"0")}${g.toString(16).padStart(2,"0")}${b.toString(16).padStart(2,"0")}`;
  }

  // ---------- 当前时间角度 ----------
  function getAngles() {
    const t = new Date();
    const sec = t.getSeconds() + t.getMilliseconds() / 1000;
    const min = t.getMinutes() + sec / 60;
    const hour = (t.getHours() % 12) + min / 60;

    return {
      sec: -Math.PI/2 + (sec/60)*Math.PI*2,
      min: -Math.PI/2 + (min/60)*Math.PI*2,
      hour: -Math.PI/2 + (hour/12)*Math.PI*2
    };
  }

  // ---------- 通用绘制刻度圈 ----------
  function drawRing(radius, color) {
    const { x:CX, y:CY } = params.center;
    const { major, medium, minor } = params.tickLength;

    ctx.save();
    ctx.translate(CX, CY);

    for (let i=0; i<600; i++) {
      const angle = -Math.PI/2 + (i / 600) * Math.PI*2;
      const isMajor = i % 10 === 0;
      const isMedium = i % 10 === 5;

      let inner, width, c;
      if (isMajor) {
        inner = radius - major;
        width = 3;
        c = color;
      } else if (isMedium) {
        inner = radius - medium;
        width = 3;
        c = darken(color, 0.4);
      } else {
        inner = radius - minor;
        width = 3;
        c = darken(color, 0.7);
      }

      ctx.beginPath();
      ctx.lineWidth = width;
      ctx.strokeStyle = c;
      ctx.moveTo(Math.cos(angle)*radius, Math.sin(angle)*radius);
      ctx.lineTo(Math.cos(angle)*inner, Math.sin(angle)*inner);
      ctx.stroke();

      if (isMajor) {
        let num = i/10 + 1;
        num = num === 1 ? 60 : num - 1;

        const text = num.toString().padStart(2,'0');
        const tx = Math.cos(angle) * (radius + params.numOuterOffset);
        const ty = Math.sin(angle) * (radius + params.numOuterOffset);

        ctx.save();
        ctx.translate(tx, ty);
        ctx.rotate(angle + Math.PI/2);
        if (num >= 16 && num <= 44) ctx.rotate(Math.PI);
        ctx.font = params.fontOuter;
        ctx.fillStyle = color;
        ctx.fillText(text, 0, 0);
        ctx.restore();
      }
    }
    ctx.restore();
  }

  // ---------- 绘制中心时圈 ----------
  function drawHourCircle() {
    const { x:CX, y:CY } = params.center;
    const r = params.rHourCircle;

    ctx.save();
    ctx.translate(CX, CY);

    for (let i=0;i<48;i++){
      const angle = -Math.PI/2 + (i/48)*Math.PI*2;
      const isMajor = i % 4 === 0;
      const isMedium = i % 4 === 2;

      let len, w, c = params.color.hour;
      if (isMajor) { len = params.tickLength.major; w=3; }
      else if (isMedium) { len=params.tickLength.medium; w=3; c = darken(c,0.4); }
      else { len=params.tickLength.minor; w=3; c = darken(c,0.7); }

      ctx.beginPath();
      ctx.lineWidth=w;
      ctx.strokeStyle=c;
      ctx.moveTo(Math.cos(angle)*r, Math.sin(angle)*r);
      ctx.lineTo(Math.cos(angle)*(r-len), Math.sin(angle)*(r-len));
      ctx.stroke();
    }

    ctx.font = params.fontHour;
    ctx.fillStyle = params.color.hour;

    const nums = [
      {a:-Math.PI/2, t:"12"},
      {a:0, t:"3"},
      {a:Math.PI/2, t:"6"},
      {a:Math.PI, t:"9"}
    ];
    for (const n of nums){
      const x = Math.cos(n.a) * (r + params.numHourOffset);
      const y = Math.sin(n.a) * (r + params.numHourOffset);
      ctx.fillText(n.t, x, y);
    }

    ctx.restore();
  }

  // ---------- 绘制指针 ----------
  function drawHand(angle, length, color) {
    const { x:CX, y:CY } = params.center;

    ctx.save();
    ctx.translate(CX, CY);
    ctx.rotate(angle);

    ctx.beginPath();
    ctx.lineWidth = 3;
    ctx.strokeStyle = color;
    ctx.moveTo(0, 0);
    ctx.lineTo(length, 0);
    ctx.stroke();

    ctx.restore();
  }

  // ---------- 主循环 ----------
  function render() {
    ctx.clearRect(0,0,canvas.width,canvas.height);

    const { hour, min, sec } = getAngles();

    drawHourCircle();
    drawHand(hour, params.rHour, params.color.hour);
    drawHand(min, params.lMin, params.color.min);
    drawHand(sec, params.lSec, params.color.sec);

    const minCenterX = params.center.x + Math.cos(min+Math.PI) * params.fixedMin;
    const minCenterY = params.center.y + Math.sin(min+Math.PI) * params.fixedMin;
    const secCenterX = params.center.x + Math.cos(sec+Math.PI) * params.fixedSec;
    const secCenterY = params.center.y + Math.sin(sec+Math.PI) * params.fixedSec;

    ctx.save();
    ctx.translate(secCenterX - params.center.x, secCenterY - params.center.y);
    drawRing(params.rSec, params.color.sec);
    ctx.restore();

    ctx.save();
    ctx.translate(minCenterX - params.center.x, minCenterY - params.center.y);
    drawRing(params.rMin, params.color.min);
    ctx.restore();

    requestAnimationFrame(render);
  }

  render();
})();
</script>
</body>
</html>
